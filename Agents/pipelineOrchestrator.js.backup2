const path = require('path');
const fs = require('fs');
const { v4: uuidv4 } = require('uuid');
const ScriptGenerationService = require('./scriptGenerationService');
const MultiInputService = require('./multiInputService');
const WebScrapingService = require('./webScrapingService');
const VideoDiscoveryService = require('./videoDiscoveryService');
const SEOOptimizationService = require('./seoOptimizationService');
const EnhancedSEOOptimizationService = require('./enhancedSEOOptimizationService'); // Hinzugef√ºgt
const EmailAgentService = require('./modules/email-agent/emailAgentService'); // Hinzugef√ºgt
const MonetizationService = require('./monetizationService'); // Hinzugef√ºgt

// WebSocket support for real-time updates
const WebSocket = require('ws');

/**
 * Pipeline Orchestrator
 * Coordinates the content generation pipeline with enhanced prompting
 */
class PipelineOrchestrator {
  constructor(services = {}) {
    this.scriptService = new ScriptGenerationService();
    this.inputService = new MultiInputService();
    this.scrapingService = new WebScrapingService();
    this.videoService = new VideoDiscoveryService();
    this.seoService = new SEOOptimizationService();
    this.enhancedSeoService = new EnhancedSEOOptimizationService(); // Hinzugef√ºgt
    this.monetizationService = new MonetizationService(); // Hinzugef√ºgt

    // Initialize thumbnail service (either from injected services or create new instance)
    this.thumbnailService = services.thumbnailGenerationService || new (require('./thumbnailGenerationService'))();

    // Initialize email agent service
    this.emailAgentService = services.emailAgentService || new EmailAgentService();

    this.jobsDir = path.join(__dirname, '../../data/jobs');
    this.outputsDir = path.join(__dirname, '../../data/outputs');

    // WebSocket server for real-time updates
    this.wss = null;
    this.clients = new Set();

    // Job queue and processing
    this.jobQueue = [];
    this.activeJobs = new Map();
    this.maxConcurrentJobs = process.env.MAX_CONCURRENT_JOBS || 3;

    // Job priorities
    this.jobPriorities = {
      'high': 3,
      'medium': 2,
      'low': 1
    };

    this.ensureDirectories();
  }

  /**
   * Ensure required directories exist
   */
  ensureDirectories() {
    [this.jobsDir, this.outputsDir].forEach(dir => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
    });
  }

  /**
   * Initialize WebSocket server for real-time updates
   */
  initializeWebSocketServer(server) {
    if (!server) return;

    this.wss = new WebSocket.Server({ server });

    this.wss.on('connection', (ws) => {
      console.log('üîå WebSocket client connected');
      this.clients.add(ws);

      ws.on('close', () => {
        console.log('üîå WebSocket client disconnected');
        this.clients.delete(ws);
      });

      ws.on('error', (error) => {
        console.error('‚ùå WebSocket error:', error);
        this.clients.delete(ws);
      });
    });

    console.log('üåê WebSocket server initialized');
  }

  /**
   * Send real-time update to all connected clients
   */
  sendRealTimeUpdate(update) {
    if (!this.wss || this.clients.size === 0) return;

    const message = JSON.stringify(update);
    this.clients.forEach(client => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(message);
      }
    });
  }

  /**
   * Add job to queue with priority
   */
  addJobToQueue(job) {
    // Remove any existing job with same ID
    this.jobQueue = this.jobQueue.filter(j => j.id !== job.id);

    // Add job to queue
    this.jobQueue.push(job);

    // Sort by priority (high to low) and then by creation time
    this.jobQueue.sort((a, b) => {
      const priorityA = this.jobPriorities[a.priority || 'medium'] || 2;
      const priorityB = this.jobPriorities[b.priority || 'medium'] || 2;

      if (priorityA !== priorityB) {
        return priorityB - priorityA; // Higher priority first
      }

      // If same priority, older jobs first
      return new Date(a.createdAt) - new Date(b.createdAt);
    });

    console.log(`üì• Job ${job.id} added to queue (priority: ${job.priority || 'medium'})`);
    this.sendRealTimeUpdate({
      type: 'job_queued',
      jobId: job.id,
      priority: job.priority || 'medium',
      queuePosition: this.jobQueue.findIndex(j => j.id === job.id) + 1,
      totalInQueue: this.jobQueue.length
    });

    // Process next job if capacity available
    this.processNextJob();
  }

  /**
   * Process next job in queue
   */
  async processNextJob() {
    // Check if we can process more jobs
    if (this.activeJobs.size >= this.maxConcurrentJobs || this.jobQueue.length === 0) {
      return;
    }

    // Get next job from queue
    const job = this.jobQueue.shift();

    // Add to active jobs
    this.activeJobs.set(job.id, job);

    console.log(`‚ö° Starting job processing: ${job.id}`);
    this.sendRealTimeUpdate({
      type: 'job_started',
      jobId: job.id,
      activeJobs: this.activeJobs.size,
      queuedJobs: this.jobQueue.length
    });

    try {
      // Process based on job type
      let result;
      switch (job.type) {
        case 'content_generation':
          result = await this.processContentGenerationJob(job);
          break;
        case 'video_repurposing':
          result = await this.processRepurposingJob(job);
          break;
        case 'channel_branding':
          result = await this.processChannelBrandingJob(job);
          break;
        case 'email_notification':
          result = await this.processEmailNotificationJob(job);
          break;
        default:
          throw new Error(`Unsupported job type: ${job.type}`);
      }

      // Mark job as completed
      job.status = 'completed';
      job.completedAt = new Date().toISOString();
      job.result = result;

      // Save job result
      this.saveJobResult(job.id, job);

      console.log(`‚úÖ Job completed: ${job.id}`);
      this.sendRealTimeUpdate({
        type: 'job_completed',
        jobId: job.id,
        result: result,
        activeJobs: this.activeJobs.size,
        queuedJobs: this.jobQueue.length
      });
    } catch (error) {
      console.error(`‚ùå Job ${job.id} failed:`, error);

      // Mark job as failed
      job.status = 'failed';
      job.failedAt = new Date().toISOString();
      job.error = error.message;

      // Save job result
      this.saveJobResult(job.id, job);

      console.log(`‚ùå Job failed: ${job.id}`);
      this.sendRealTimeUpdate({
        type: 'job_failed',
        jobId: job.id,
        error: error.message,
        activeJobs: this.activeJobs.size,
        queuedJobs: this.jobQueue.length
      });
    } finally {
      // Remove from active jobs
      this.activeJobs.delete(job.id);

      // Process next job
      setTimeout(() => this.processNextJob(), 1000);
    }
  }

  /**
   * Process a content generation job with enhanced monitoring
   */
  async processContentGenerationJob(jobData) {
    try {
      console.log('ü§ñ Processing content generation job...');

      // Extract parameters
      const {
        jobId = uuidv4(),
        contentType,
        targetLength,
        tone,
        topic,
        trendingKeywords = [],
        audience = 'all',
        sourceContent = '',
        customInstructions = '',
        sendNotification = false, // Neue Option f√ºr E-Mail-Benachrichtigung
        notificationEmail = null,
        priority = 'medium'
      } = jobData;

      // Send real-time update
      this.sendRealTimeUpdate({
        type: 'job_progress',
        jobId: jobId,
        stage: 'initializing',
        progress: 0,
        message: 'Initializing content generation job'
      });

      // Generate prompt using enhanced service
      const promptResult = this.enhancedPromptingService.generateEnhancedPrompt({
        contentType,
        targetLength,
        tone,
        topic,
        trendingKeywords,
        audience,
        sourceContent,
        customInstructions
      });

      console.log(`üìù Generated enhanced prompt with quality score: ${promptResult.metadata.qualityScore}/100`);
      this.sendRealTimeUpdate({
        type: 'job_progress',
        jobId: jobId,
        stage: 'prompt_generation',
        progress: 10,
        message: `Generated enhanced prompt with quality score: ${promptResult.metadata.qualityScore}/100`
      });

      // In a real implementation, this would call an actual LLM
      // For now, we'll simulate the response
      const simulatedResponse = await this.simulateLLMResponse(promptResult.prompt);

      // Assess response quality
      const qualityScore = this.enhancedPromptingService.assessResponseQuality(
        simulatedResponse,
        { contentType, targetLength, tone, topic, trendingKeywords, audience }
      );

      console.log(`‚≠ê Response quality score: ${qualityScore}/100`);
      this.sendRealTimeUpdate({
        type: 'job_progress',
        jobId: jobId,
        stage: 'quality_assessment',
        progress: 20,
        message: `Response quality score: ${qualityScore}/100`
      });

      // NEW: Calculate potential monetization for this content
      const monetizationData = this.estimateMonetizationPotential({
        contentType,
        targetLength,
        qualityScore,
        audience,
        trendingKeywords
      });

      this.sendRealTimeUpdate({
        type: 'job_progress',
        jobId: jobId,
        stage: 'monetization_analysis',
        progress: 30,
        message: 'Performed monetization analysis'
      });

      // NEW: Generate thumbnail for this content
      const thumbnailData = await this.generateThumbnail({
        title: topic,
        contentType,
        trendingKeywords,
        qualityScore,
        platform: 'youtube'
      });

      this.sendRealTimeUpdate({
        type: 'job_progress',
        jobId: jobId,
        stage: 'thumbnail_generation',
        progress: 40,
        message: 'Generated thumbnail'
      });

      // NEW: Generate AI thumbnail for this content
      const aiThumbnailData = await this.generateAIStaticThumbnail({
        title: topic,
        contentType,
        trendingKeywords,
        qualityScore,
        platform: 'youtube'
      });

      this.sendRealTimeUpdate({
        type: 'job_progress',
        jobId: jobId,
        stage: 'ai_thumbnail_generation',
        progress: 50,
        message: 'Generated AI thumbnail'
      });

      // NEW: Generate animated thumbnail for short content
      let animatedThumbnailData = null;
      if (contentType === 'short' || contentType === 'viral_shorts') {
        animatedThumbnailData = await this.generateAnimatedShortThumbnail({
          title: topic,
          contentType,
          trendingKeywords,
          qualityScore,
          platform: 'youtube_shorts'
        });
      }

      this.sendRealTimeUpdate({
        type: 'job_progress',
        jobId: jobId,
        stage: 'animated_thumbnail_generation',
        progress: 60,
        message: contentType === 'short' || contentType === 'viral_shorts' ?
                  'Generated animated thumbnail' : 'Skipped animated thumbnail (not a short)'
      });

      // Save results
      const result = {
        jobId,
        prompt: promptResult.prompt,
        response: simulatedResponse,
        qualityScore,
        metadata: promptResult.metadata,
        monetization: monetizationData,
        thumbnail: thumbnailData,
        aiThumbnail: aiThumbnailData,
        animatedThumbnail: animatedThumbnailData,
        generatedAt: new Date().toISOString()
      };

      this.saveJobResult(jobId, result);

      // Sende E-Mail-Benachrichtigung wenn gew√ºnscht
      if (sendNotification && notificationEmail) {
        await this.sendJobCompletionEmail(jobId, result, notificationEmail);
      }

      this.sendRealTimeUpdate({
        type: 'job_progress',
        jobId: jobId,
        stage: 'completed',
        progress: 100,
        message: 'Job completed successfully'
      });

      return result;
    } catch (error) {
      console.error('‚ùå Failed to process job:', error);
      throw error;
    }
  }

  /**
   * Process video repurposing job with enhanced monitoring
   */
  async processRepurposingJob(jobData) {
    try {
      console.log('üîÑ Processing video repurposing job...');

      const {
        originalVideoId,
        originalTitle,
        targetPlatform = 'youtube_shorts',
        targetLength = 60,
        template = 'hookFirst',
        customHook = null,
        sendNotification = false, // Neue Option f√ºr E-Mail-Benachrichtigung
        notificationEmail = null,
        priority = 'medium'
      } = jobData;

      // Send real-time update
      this.sendRealTimeUpdate({
        type: 'job_progress',
        jobId: jobData.jobId || uuidv4(),
        stage: 'initializing',
        progress: 0,
        message: 'Initializing video repurposing job'
      });

      // Load original video data (in real implementation, this would come from database)
      const originalVideoData = await this.loadOriginalVideoData(originalVideoId);

      if (!originalVideoData) {
        throw new Error(`Original video ${originalVideoId} not found`);
      }

      // Analyze video for highlights
      console.log(`üîç Analyzing video "${originalTitle}" for highlights...`);
      this.sendRealTimeUpdate({
        type: 'job_progress',
        jobId: jobData.jobId || uuidv4(),
        stage: 'highlight_analysis',
        progress: 20,
        message: `Analyzing video "${originalTitle}" for highlights`
      });

      const highlightData = await this.repurposingService.analyzeVideoForHighlights(originalVideoData);

      // Create short from highlights
      console.log(`üé¨ Creating ${targetLength}-second short for ${targetPlatform}...`);
      this.sendRealTimeUpdate({
        type: 'job_progress',
        jobId: jobData.jobId || uuidv4(),
        stage: 'short_creation',
        progress: 40,
        message: `Creating ${targetLength}-second short for ${targetPlatform}`
      });

      const shortConfig = await this.repurposingService.createShortFromHighlights(
        highlightData,
        {
          targetPlatform,
          targetLength,
          template,
          customHook
        }
      );

      // Estimate monetization potential for the short
      const monetizationData = this.estimateShortMonetizationPotential(shortConfig);

      // NEW: Generate animated thumbnail for the short using Whisk AI
      const thumbnailData = await this.generateAnimatedShortThumbnail({
        title: originalTitle,
        contentType: 'short',
        trendingKeywords: originalVideoData.trendingKeywords || [],
        platform: targetPlatform.includes('short') ? 'youtube_shorts' : targetPlatform
      }, {
        width: 1080,
        height: 1920 // Vertical format for shorts
      });

      // Save results
      const jobId = jobData.jobId || uuidv4();
      const result = {
        jobId,
        originalVideoId,
        originalTitle,
        shortConfig,
        monetization: monetizationData,
        thumbnail: thumbnailData,
        highlightData,
        generatedAt: new Date().toISOString()
      };

      this.saveJobResult(jobId, result);

      // Sende E-Mail-Benachrichtigung wenn gew√ºnscht
      if (sendNotification && notificationEmail) {
        await this.sendJobCompletionEmail(jobId, result, notificationEmail);
      }

      console.log(`‚úÖ Short created successfully: ${shortConfig.shortId}`);
      this.sendRealTimeUpdate({
        type: 'job_progress',
        jobId: jobId,
        stage: 'completed',
        progress: 100,
        message: `Short created successfully: ${shortConfig.shortId}`
      });

      return result;
    } catch (error) {
      console.error('‚ùå Failed to process repurposing job:', error);
      throw error;
    }
  }

  /**
   * Process channel branding job
   */
  async processChannelBrandingJob(brandingData) {
    try {
      console.log('üé® Processing channel branding job...');

      const {
        channelName,
        channelType,
        tagline,
        generateBanner = true,
        generateIcons = true,
        generateThumbnails = true,
        sendNotification = false, // Neue Option f√ºr E-Mail-Benachrichtigung
        notificationEmail = null
      } = brandingData;

      const jobId = uuidv4();
      const results = {
        jobId,
        channelName,
        channelType,
        assets: {}
      };

      // Generate banner if requested
      if (generateBanner) {
        console.log(`üñºÔ∏è Generating banner for ${channelName}...`);
        const bannerData = await this.generateBanner({
          channelName,
          tagline,
          theme: channelType
        });
        results.assets.banner = bannerData;
      }

      // Generate icons if requested
      if (generateIcons) {
        console.log(`üñºÔ∏è Generating icons for ${channelName}...`);
        const iconData = await this.generateChannelIcons(channelName, channelType);
        results.assets.icons = iconData;
      }

      // Generate sample thumbnails if requested
      if (generateThumbnails) {
        console.log(`üñºÔ∏è Generating sample thumbnails for ${channelName}...`);
        const thumbnailData = await this.generateChannelThumbnails(channelName, channelType);
        results.assets.thumbnails = thumbnailData;
      }

      // Save results
      this.saveJobResult(jobId, results);

      // Sende E-Mail-Benachrichtigung wenn gew√ºnscht
      if (sendNotification && notificationEmail) {
        await this.sendJobCompletionEmail(jobId, results, notificationEmail);
      }

      console.log(`‚úÖ Channel branding completed for ${channelName}`);
      return results;
    } catch (error) {
      console.error('‚ùå Failed to process channel branding job:', error);
      throw error;
    }
  }

  /**
   * NEW: Process email notification job
   */
  async processEmailNotificationJob(notificationData) {
    try {
      console.log('üìß Processing email notification job...');

      const {
        jobId = uuidv4(),
        recipients,
        subject,
        body,
        templateId = null,
        sendBulk = false,
        sendNotification = false, // Neue Option f√ºr E-Mail-Benachrichtigung
        notificationEmail = null
      } = notificationData;

      let result;

      if (sendBulk && Array.isArray(recipients)) {
        // Send bulk email
        const bulkResult = await this.emailAgentService.sendBulkEmail(recipients, {
          subject,
          body
        });
        result = {
          jobId,
          type: 'bulk-email',
          result: bulkResult,
          recipientsCount: recipients.length,
          generatedAt: new Date().toISOString()
        };
      } else if (templateId) {
        // Send email using template
        const template = await this.emailAgentService.getTemplate(templateId);
        if (template.success) {
          const sendResult = await this.emailAgentService.sendEmail({
            to: recipients,
            subject: template.template.subject,
            body: template.template.body
          });
          result = {
            jobId,
            type: 'template-email',
            result: sendResult,
            templateId,
            generatedAt: new Date().toISOString()
          };
        } else {
          throw new Error(`Failed to load template: ${template.error}`);
        }
      } else {
        // Send single email
        const sendResult = await this.emailAgentService.sendEmail({
          to: recipients,
          subject,
          body
        });
        result = {
          jobId,
          type: 'single-email',
          result: sendResult,
          generatedAt: new Date().toISOString()
        };
      }

      // Save results
      this.saveJobResult(jobId, result);

      // Sende E-Mail-Benachrichtigung wenn gew√ºnscht
      if (sendNotification && notificationEmail) {
        await this.sendJobCompletionEmail(jobId, result, notificationEmail);
      }

      console.log(`‚úÖ Email notification job completed: ${jobId}`);
      return result;
    } catch (error) {
      console.error('‚ùå Failed to process email notification job:', error);
      throw error;
    }
  }

  /**
   * NEW: Generate thumbnail for content
   */
  async generateThumbnail(videoData, options = {}) {
    try {
      console.log(`üñºÔ∏è Generating thumbnail for "${videoData.title}"`);

      const thumbnailMetadata = await this.thumbnailService.generateThumbnail(videoData, options);

      console.log(`‚úÖ Thumbnail generated: ${thumbnailMetadata.thumbnailId}`);
      return thumbnailMetadata;
    } catch (error) {
      console.error('‚ùå Failed to generate thumbnail:', error);
      // Return fallback data instead of throwing error
      return {
        thumbnailId: 'fallback-' + uuidv4(),
        videoTitle: videoData.title,
        platform: options.platform || 'youtube',
        template: 'boldText',
        error: error.message
      };
    }
  }

  /**
   * NEW: Generate AI-powered static thumbnail for content
   */
  async generateAIStaticThumbnail(videoData, options = {}) {
    try {
      console.log(`üé® Generating AI thumbnail for "${videoData.title}"`);

      const thumbnailMetadata = await this.thumbnailService.generateAIStaticThumbnail(videoData, options);

      console.log(`‚úÖ AI Thumbnail generated: ${thumbnailMetadata.thumbnailId || 'external'}`);
      return thumbnailMetadata;
    } catch (error) {
      console.error('‚ùå Failed to generate AI thumbnail:', error);
      // Return fallback data instead of throwing error
      return {
        thumbnailId: 'fallback-' + uuidv4(),
        videoTitle: videoData.title,
        platform: options.platform || 'youtube',
        template: 'boldText',
        isAI: false,
        error: error.message
      };
    }
  }

  /**
   * NEW: Generate animated thumbnail for short content using Whisk AI and WAN 2.2
   * @param {object} videoData - Video data for thumbnail generation
   * @param {object} options - Generation options
   * @returns {Promise<object>} Animated thumbnail metadata
   */
  async generateAnimatedShortThumbnail(videoData, options = {}) {
    try {
      console.log(`üé¨ Generating animated thumbnail for short: "${videoData.title}"`);

      // Use the new animated thumbnail generation method
      const thumbnailMetadata = await this.thumbnailService.generateAnimatedShortThumbnail(videoData, options);

      console.log(`‚úÖ Animated thumbnail generated: ${thumbnailMetadata.thumbnailId || 'external'}`);
      return thumbnailMetadata;
    } catch (error) {
      console.error('‚ùå Failed to generate animated thumbnail:', error);
      // Return fallback data instead of throwing error
      return {
        thumbnailId: 'fallback-' + uuidv4(),
        videoTitle: videoData.title,
        platform: options.platform || 'youtube_shorts',
        template: 'boldText',
        isAnimated: true,
        error: error.message
      };
    }
  }

  /**
   * NEW: Generate banner for channel
   */
  async generateBanner(bannerData, options = {}) {
    try {
      console.log(`üñºÔ∏è Generating banner for "${bannerData.channelName}"`);

      const bannerMetadata = await this.thumbnailService.generateBanner(bannerData, options);

      console.log(`‚úÖ Banner generated: ${bannerMetadata.bannerId}`);
      return bannerMetadata;
    } catch (error) {
      console.error('‚ùå Failed to generate banner:', error);
      // Return fallback data instead of throwing error
      return {
        bannerId: 'fallback-' + uuidv4(),
        channelName: bannerData.channelName,
        template: 'boldText',
        error: error.message
      };
    }
  }

  /**
   * NEW: Generate channel icons
   */
  async generateChannelIcons(channelName, channelType) {
    try {
      console.log(`üñºÔ∏è Generating icons for "${channelName}"`);

      const iconMetadata = await this.thumbnailService.generateChannelIcons(channelName, channelType);

      console.log(`‚úÖ Icons generated: ${iconMetadata.iconIds}`);
      return iconMetadata;
    } catch (error) {
      console.error('‚ùå Failed to generate icons:', error);
      // Return fallback data instead of throwing error
      return {
        iconIds: ['fallback-' + uuidv4()],
        channelName: channelName,
        error: error.message
      };
    }
  }

  /**
   * NEW: Generate sample thumbnails for channel
   */
  async generateChannelThumbnails(channelName, channelType) {
    try {
      console.log(`üñºÔ∏è Generating sample thumbnails for "${channelName}"`);

      const thumbnailMetadata = await this.thumbnailService.generateChannelThumbnails(channelName, channelType);

      console.log(`‚úÖ Thumbnails generated: ${thumbnailMetadata.thumbnailIds}`);
      return thumbnailMetadata;
    } catch (error) {
      console.error('‚ùå Failed to generate thumbnails:', error);
      // Return fallback data instead of throwing error
      return {
        thumbnailIds: ['fallback-' + uuidv4()],
        channelName: channelName,
        error: error.message
      };
    }
  }

  /**
   * Send email notification for job completion
   */
  async sendJobCompletionEmail(jobId, result, recipientEmail) {
    try {
      console.log(`üìß Sending completion email for job ${jobId} to ${recipientEmail}`);

      const emailContent = await this.emailAgentService.generateEmailContent({
        topic: 'Content Generation Job Completed',
        recipientType: 'user',
        tone: 'professional',
        language: 'en',
        customInstructions: `Job ID: ${jobId}
Quality Score: ${result.qualityScore}/100
Content Type: ${result.metadata?.contentType || 'Unknown'}
Generated at: ${result.generatedAt}`
      });

      if (emailContent.success) {
        const emailResult = await this.emailAgentService.sendEmail({
          to: recipientEmail,
          subject: emailContent.subject,
          body: emailContent.body,
          from: process.env.SMTP_USER
        });

        if (emailResult.success) {
          console.log(`‚úÖ Completion email sent successfully for job ${jobId}`);
        } else {
          console.error(`‚ùå Failed to send completion email for job ${jobId}:`, emailResult.error);
        }
      } else {
        console.error(`‚ùå Failed to generate completion email content for job ${jobId}:`, emailContent.error);
      }
    } catch (error) {
      console.error(`‚ùå Error sending completion email for job ${jobId}:`, error);
    }
  }

  /**
   * Load original video data (in real implementation, this would come from database)
   */
  async loadOriginalVideoData(videoId) {
    try {
      console.log(`üîç Loading original video data for video ID: ${videoId}`);

      // Simulate loading video data
      const videoData = {
        videoId,
        title: 'Original Video Title',
        description: 'Original Video Description',
        duration: 300,
        trendingKeywords: ['keyword1', 'keyword2']
      };

      console.log(`‚úÖ Original video data loaded for video ID: ${videoId}`);
      return videoData;
    } catch (error) {
      console.error(`‚ùå Failed to load original video data for video ID: ${videoId}`, error);
      throw error;
    }
  }

  /**
   * Estimate monetization potential for content
   */
  estimateMonetizationPotential(contentData) {
    try {
      console.log(`üí∞ Estimating monetization potential for content...`);

      // Simulate monetization analysis
      const monetizationData = {
        potentialEarnings: 100,
        potentialViews: 10000,
        potentialEngagement: 0.1
      };

      console.log(`üí∞ Monetization potential estimated: ${JSON.stringify(monetizationData)}`);
      return monetizationData;
    } catch (error) {
      console.error(`‚ùå Failed to estimate monetization potential for content:`, error);
      throw error;
    }
  }

  /**
   * Estimate monetization potential for short content
   */
  estimateShortMonetizationPotential(shortConfig) {
    try {
      console.log(`üí∞ Estimating monetization potential for short...`);

      // Simulate monetization analysis
      const monetizationData = {
        potentialEarnings: 10,
        potentialViews: 1000,
        potentialEngagement: 0.2
      };

      console.log(`üí∞ Monetization potential estimated: ${JSON.stringify(monetizationData)}`);
      return monetizationData;
    } catch (error) {
      console.error(`‚ùå Failed to estimate monetization potential for short:`, error);
      throw error;
    }
  }

  /**
   * Simulate LLM response
   */
  async simulateLLMResponse(prompt) {
    try {
      console.log(`üí¨ Simulating LLM response for prompt: ${prompt}`);

      // Simulate response
      const simulatedResponse = `Simulated response for prompt "${prompt}"`;

      console.log(`üí¨ Simulated LLM response: ${simulatedResponse}`);
      return simulatedResponse;
    } catch (error) {
      console.error(`‚ùå Failed to simulate LLM response for prompt: ${prompt}`, error);
      throw error;
    }
  }

  /**
   * Save job result
   */
  saveJobResult(jobId, result) {
    try {
      console.log(`üíæ Saving job result for job ID: ${jobId}`);

      const filePath = path.join(this.outputsDir, `${jobId}.json`);
      fs.writeFileSync(filePath, JSON.stringify(result, null, 2));

      console.log(`üíæ Job result saved for job ID: ${jobId}`);
    } catch (error) {
      console.error(`‚ùå Failed to save job result for job ID: ${jobId}`, error);
      throw error;
    }
  }

  /**
   * Generate fallback banner
   */
  async generateFallbackBanner(bannerData, options = {}) {
    try {
      console.log('üé® Generating fallback banner...');

      // For now, we'll just return placeholder data
      // In a real implementation, this would generate an actual banner
      return {
        bannerId: 'fallback-' + uuidv4(),
        channelName: bannerData.channelName,
        theme: options.theme || 'default',
        generatedAt: new Date().toISOString()
      };
    } catch (error) {
      console.error('‚ùå Failed to generate fallback banner:', error);
      return {
        bannerId: 'fallback-' + uuidv4(),
        channelName: bannerData.channelName,
        theme: options.theme || 'default',
        error: error.message
      };
    }
  }

  /**
   * NEW: Generate channel icons
   */
  async generateChannelIcons(channelName, channelType) {
    try {
      console.log(`üñºÔ∏è Generating icons for "${channelName}" (${channelType})`);

      // For now, we'll just return placeholder data
      // In a real implementation, this would generate actual icons
      const iconSets = [
        { name: 'small', size: '32x32' },
        { name: 'medium', size: '64x64' },
        { name: 'large', size: '128x128' },
        { name: 'app', size: '512x512' }
      ];

      const icons = iconSets.map(set => ({
        id: uuidv4(),
        name: `${channelName.toLowerCase()}-${set.name}`,
        size: set.size,
        type: channelType,
        generatedAt: new Date().toISOString()
      }));

      console.log(`‚úÖ Generated ${icons.length} icons for ${channelName}`);
      return icons;
    } catch (error) {
      console.error('‚ùå Failed to generate icons:', error);
      return [];
    }
  }

  /**
   * Generate sample thumbnails for a channel
   */
  async generateSampleThumbnails(channelName, channelType) {
    try {
      console.log(`üé® Generating sample thumbnails for ${channelName} (${channelType})`);

      const thumbnails = [];
      const contentTypes = ['news', 'tutorial', 'review', 'entertainment', 'explanation'];

      // Generate 5 sample thumbnails
      for (let i = 0; i < 5; i++) {
        const contentType = contentTypes[i % contentTypes.length];
        const thumbnailData = await this.generateThumbnail({
          title: `${channelName} ${contentType} sample`,
          contentType,
          trendingKeywords: [channelType, contentType],
          qualityScore: 90 + Math.floor(Math.random() * 10),
          platform: 'youtube'
        });

        thumbnails.push(thumbnailData);
      }

      console.log(`‚úÖ Generated ${thumbnails.length} sample thumbnails for ${channelName}`);
      return thumbnails;
    } catch (error) {
      console.error('‚ùå Failed to generate sample thumbnails:', error);
      return [];
    }
  }

  /**
   * Load original video data (simulated)
   */
  async loadOriginalVideoData(videoId) {
    // In a real implementation, this would load from database
    // For demo purposes, we'll return sample data for the top-performing video
    if (videoId === 'vid_002') {
      return {
        videoId: 'vid_002',
        title: 'Produktivit√§t mit KI-Tools',
        transcript: `Willkommen zu unserem Video √ºber Produktivit√§t mit KI-Tools. Wusstet ihr, dass ihr mit den richtigen KI-Tools eure Produktivit√§t um bis zu 300% steigern k√∂nnt? In diesem Tutorial zeige ich euch genau, wie das geht. Zuerst m√ºssen wir verstehen, welche Tools wirklich effektiv sind. Die besten Tools sind solche, die nahtlos in euren Arbeitsablauf integriert werden k√∂nnen. √úberraschend ist, dass viele Menschen teure Tools kaufen, die sie dann nicht nutzen. Der Schl√ºssel zur Produktivit√§t liegt nicht in der Anzahl der Tools, sondern in der richtigen Kombination. Was viele nicht wissen: Die besten Ergebnisse erzielt ihr, wenn ihr eure Tools systematisch einsetzt. Lasst uns einen Blick auf die praktischen Beispiele werfen. Hier sehen wir, wie ein Projekt von 10 Stunden auf 3 Stunden reduziert werden kann. Das spart nicht nur Zeit, sondern auch Geld. Gef√§llt dir der Inhalt? Dann abonniere f√ºr mehr!`,
        timestamps: [
          { start: 0, end: 5 },
          { start: 5, end: 15 },
          { start: 15, end: 25 },
          { start: 25, end: 35 },
          { start: 35, end: 45 },
          { start: 45, end: 55 },
          { start: 55, end: 65 },
          { start: 65, end: 75 },
          { start: 75, end: 85 },
          { start: 85, end: 95 }
        ],
        trendingKeywords: ['KI', 'Produktivit√§t', 'Tools', 'Automatisierung'],
        engagementMetrics: {
          timeline: [
            { timestamp: 0, duration: 5, engagementRate: 0.2 },
            { timestamp: 5, duration: 10, engagementRate: 0.8 },
            { timestamp: 15, duration: 10, engagementRate: 0.6 },
            { timestamp: 25, duration: 10, engagementRate: 0.4 },
            { timestamp: 35, duration: 10, engagementRate: 0.9 },
            { timestamp: 45, duration: 10, engagementRate: 0.7 },
            { timestamp: 55, duration: 10, engagementRate: 0.5 },
            { timestamp: 65, duration: 10, engagementRate: 0.85 },
            { timestamp: 75, duration: 10, engagementRate: 0.65 },
            { timestamp: 85, duration: 10, engagementRate: 0.4 }
          ]
        },
        monetizationData: {
          revenueTimeline: [
            { timestamp: 0, duration: 5, revenue: 10.50 },
            { timestamp: 5, duration: 10, revenue: 45.20 },
            { timestamp: 15, duration: 10, revenue: 32.10 },
            { timestamp: 25, duration: 10, revenue: 22.80 },
            { timestamp: 35, duration: 10, revenue: 68.90 },
            { timestamp: 45, duration: 10, revenue: 41.30 },
            { timestamp: 55, duration: 10, revenue: 28.70 },
            { timestamp: 65, duration: 10, revenue: 55.40 },
            { timestamp: 75, duration: 10, revenue: 38.20 },
            { timestamp: 85, duration: 10, revenue: 12.00 }
          ]
        }
      };
    }

    return null;
  }

  /**
   * Estimate monetization potential for short videos
   */
  estimateShortMonetizationPotential(shortConfig) {
    // Estimate views for short based on original video performance
    // Shorts typically have higher engagement but shorter watch time
    const estimatedViews = 50000; // Beispielwert

    // Shorts haben oft h√∂here CTR aber niedrigere RPM
    const videoData = {
      views: estimatedViews,
      adPerformance: {
        ctr: 0.05,  // 5% CTR (h√∂her als Long-Form)
        cpm: 3.0,   // $3.00 CPM (niedriger als Long-Form)
        engagement: 0.3 // 30% Engagement
      }
    };

    const revenue = this.monetizationService.calculateVideoRevenue(videoData);

    return {
      estimatedViews: videoData.views,
      estimatedRevenue: revenue.totalRevenue,
      creatorRevenue: revenue.creatorRevenue,
      revenueBreakdown: revenue.breakdown,
      monetizationConfidence: 'medium'
    };
  }

  /**
   * Get repurposing statistics
   */
  getRepurposingStats() {
    return this.repurposingService.getStats();
  }

  /**
   * Get thumbnail statistics
   */
  getThumbnailStats() {
    return this.thumbnailService.getStats();
  }

  /**
   * Estimate monetization potential for content
   */
  estimateMonetizationPotential(contentData) {
    const {
      contentType,
      targetLength,
      qualityScore,
      audience,
      trendingKeywords = []
    } = contentData;

    // Estimate views based on content type and quality
    let estimatedViews = 0;
    switch(contentType) {
      case 'news':
        estimatedViews = qualityScore > 80 ? 50000 : qualityScore > 60 ? 25000 : 10000;
        break;
      case 'tutorial':
        estimatedViews = qualityScore > 80 ? 100000 : qualityScore > 60 ? 50000 : 20000;
        break;
      case 'review':
        estimatedViews = qualityScore > 80 ? 75000 : qualityScore > 60 ? 35000 : 15000;
        break;
      case 'entertainment':
        estimatedViews = qualityScore > 80 ? 150000 : qualityScore > 60 ? 75000 : 30000;
        break;
      case 'explanation':
        estimatedViews = qualityScore > 80 ? 80000 : qualityScore > 60 ? 40000 : 15000;
        break;
      default:
        estimatedViews = qualityScore > 80 ? 50000 : qualityScore > 60 ? 25000 : 10000;
    }

    // Adjust for trending keywords
    if (trendingKeywords.length > 0) {
      estimatedViews *= (1 + (trendingKeywords.length * 0.1));
    }

    // Adjust for target length
    const lengthMultiplier = {
      '30s': 0.5,
      '1min': 0.7,
      '5min': 1.0,
      '10min': 1.3,
      '15min': 1.5
    };
    estimatedViews *= lengthMultiplier[targetLength] || 1.0;

    // Calculate estimated revenue using monetization service
    const videoData = {
      views: Math.round(estimatedViews),
      adPerformance: {
        ctr: qualityScore > 80 ? 0.03 : qualityScore > 60 ? 0.025 : 0.02,
        cpm: qualityScore > 80 ? 7.0 : qualityScore > 60 ? 6.0 : 5.0,
        engagement: qualityScore > 80 ? 0.2 : qualityScore > 60 ? 0.15 : 0.1
      }
    };

    const revenue = this.monetizationService.calculateVideoRevenue(videoData);

    return {
      estimatedViews: videoData.views,
      estimatedRevenue: revenue.totalRevenue,
      creatorRevenue: revenue.creatorRevenue,
      revenueBreakdown: revenue.breakdown,
      monetizationConfidence: qualityScore > 80 ? 'high' : qualityScore > 60 ? 'medium' : 'low'
    };
  }

  /**
   * Simulate LLM response (for demo purposes)
   */
  async simulateLLMResponse(prompt) {
    // Simulate processing time
    await new Promise(resolve => setTimeout(resolve, 100 + Math.random() * 500));

    // Generate a mock response based on prompt content
    const topicMatch = prompt.match(/YouTube video about "([^"]+)"/);
    const topic = topicMatch ? topicMatch[1] : "default topic";

    const contentTypeMatch = prompt.match(/Create a ([^ ]+) for/);
    const contentType = contentTypeMatch ? contentTypeMatch[1] : "news";

    let response = "";

    switch(contentType) {
      case 'news':
        response = `Wusstet ihr, dass aktuelle Entwicklungen im Bereich "${topic}" unsere Zukunft beeinflussen? Heute zeigen wir euch die wichtigsten Fakten.\n\n`;
        response += "1. Aktuelle Entwicklungen\n";
        response += "2. Auswirkungen auf die Gesellschaft\n";
        response += "3. Zuk√ºnftige Trends\n\n";
        response += "Bleibt dran f√ºr weitere Updates!";
        break;

      case 'tutorial':
        response = `In diesem Tutorial zeige ich euch, wie ihr "${topic}" meistert.\n\n`;
        response += "Schritt 1: Vorbereitung\n";
        response += "Schritt 2: Durchf√ºhrung\n";
        response += "Schritt 3: √úberpr√ºfung\n\n";
        response += "Weitere √úbung empfohlen!";
        break;

      default:
        response = `Willkommen zu unserem Video √ºber "${topic}".\n\n`;
        response += "Abschnitt 1: Einf√ºhrung\n";
        response += "Abschnitt 2: Hauptteil\n";
        response += "Abschnitt 3: Zusammenfassung\n\n";
        response += "Danke f√ºrs Zuschauen!";
    }

    return response;
  }

  /**
   * Save job result to file
   */
  saveJobResult(jobId, result) {
    try {
      const filename = `job-result-${jobId}.json`;
      const filepath = path.join(this.outputsDir, filename);

      fs.writeFileSync(filepath, JSON.stringify(result, null, 2));
      console.log(`üíæ Job result saved: ${filename}`);
    } catch (error) {
      console.error('‚ùå Failed to save job result:', error);
    }
  }

  /**
   * Generate content using enhanced prompting with templates
   */
  async generateContentWithTemplates(jobData) {
    try {
      console.log('ü§ñ Generating content with enhanced prompting and templates...');

      const {
        contentType,
        targetLength,
        tone,
        topic,
        trendingKeywords = [],
        audience = 'all',
        sourceContent = '',
        customInstructions = '',
        templateName = null
      } = jobData.scriptParameters || {};

      // Use enhanced prompting service with template support
      const promptResult = this.enhancedPromptingService.generateEnhancedPrompt({
        contentType,
        targetLength,
        tone,
        topic,
        trendingKeywords,
        audience,
        sourceContent,
        customInstructions,
        templateName
      });

      console.log(`üìù Generated enhanced prompt with quality score: ${promptResult.metadata.qualityScore}/100`);

      // In a real implementation, this would call an actual LLM
      // For now, we'll simulate the response
      const simulatedResponse = await this.simulateLLMResponse(promptResult.prompt);

      // Assess response quality
      const qualityScore = this.enhancedPromptingService.assessResponseQuality(
        simulatedResponse,
        { contentType, targetLength, tone, topic, trendingKeywords, audience }
      );

      console.log(`‚≠ê Response quality score: ${qualityScore}/100`);

      // NEW: Calculate potential monetization for this content
      const monetizationData = this.estimateMonetizationPotential({
        contentType,
        targetLength,
        qualityScore,
        audience,
        trendingKeywords
      });

      // NEW: Generate thumbnail for this content
      const thumbnailData = await this.generateThumbnail({
        title: topic,
        contentType,
        trendingKeywords,
        qualityScore,
        platform: 'youtube'
      });

      // Save results
      const jobId = uuidv4();
      const result = {
        jobId,
        prompt: promptResult.prompt,
        response: simulatedResponse,
        qualityScore,
        metadata: promptResult.metadata,
        monetization: monetizationData,
        thumbnail: thumbnailData,
        generatedAt: new Date().toISOString()
      };

      this.saveJobResult(jobId, result);

      return result;
    } catch (error) {
      console.error('‚ùå Failed to generate content with templates:', error);
      throw error;
    }
  }

  /**
   * List available templates
   */
  listTemplates(templateType) {
    return this.templateService.listTemplates(templateType);
  }

  /**
   * Load a specific template
   */
  loadTemplate(templateType, templateName) {
    return this.templateService.loadTemplate(templateType, templateName);
  }

  /**
   * Save a template
   */
  saveTemplate(templateType, templateName, templateData) {
    return this.templateService.saveTemplate(templateType, templateName, templateData);
  }

  /**
   * Check if a template is available
   */
  isTemplateAvailable(templateType, templateName) {
    return this.templateService.isTemplateAvailable(templateType, templateName);
  }

  /**
   * Get monetization statistics
   */
  getMonetizationStats() {
    return this.monetizationService.getStats();
  }

  /**
   * Create sponsorship contract
   */
  async createSponsorshipContract(contractData) {
    return await this.monetizationService.createSponsorshipContract(contractData);
  }

  /**
   * Create product listing
   */
  async createProduct(productData) {
    return await this.monetizationService.createProduct(productData);
  }

  /**
   * Erweiterte Pipeline-Erstellung mit SEO-Optimierung
   */
  async createPipeline(config = {}) {
    console.log('üöÄ Erstelle erweiterte Pipeline mit SEO-Optimierung...');

    const pipelineId = `pipeline_${Date.now()}`;
    const startTime = Date.now();

    // Standardkonfiguration
    const pipelineConfig = {
      scrapeContent: true,
      generateScripts: true,
      createThumbnails: true,
      optimizeSEO: true,
      contentType: 'tutorial',
      targetLength: '10min',
      tone: 'educational',
      audience: 'developers',
      maxScripts: 5,
      language: 'de',
      ...config
    };

    const pipelineResult = {
      pipelineId,
      config: pipelineConfig,
      steps: [],
      data: {},
      metadata: {
        startedAt: new Date().toISOString(),
        status: 'running'
      }
    };

    try {
      // Schritt 1: Content-Scraping
      if (pipelineConfig.scrapeContent) {
        pipelineResult.steps.push({ name: 'content_scraping', status: 'running' });
        console.log('üîç Starte Content-Scraping...');

        const scrapingResult = await this.scrapingService.scrapeMultipleSources({
          sources: ['reddit', 'hackernews', 'twitter', 'youtube'],
          categories: ['technology', 'ai', 'politics'],
          maxItems: 20
        });

        pipelineResult.data.scrapedContent = scrapingResult;
        pipelineResult.steps[pipelineResult.steps.length - 1].status = 'completed';
        pipelineResult.steps[pipelineResult.steps.length - 1].result = scrapingResult;
        console.log('‚úÖ Content-Scraping abgeschlossen');
      }

      // Schritt 2: Video-Entdeckung
      pipelineResult.steps.push({ name: 'video_discovery', status: 'running' });
      console.log('üîç Starte Video-Entdeckung...');

      const discoveryResult = await this.videoService.discoverTrendingVideos({
        categories: ['politics', 'ai_tech'],
        maxVideosPerCategory: 5,
        timeRange: '1_week',
        minViews: 1000,
        topic: pipelineConfig.contentType
      });

      pipelineResult.data.videoDiscovery = discoveryResult;
      pipelineResult.steps[pipelineResult.steps.length - 1].status = 'completed';
      pipelineResult.steps[pipelineResult.steps.length - 1].result = discoveryResult;
      console.log('‚úÖ Video-Entdeckung abgeschlossen');

      // Schritt 3: Script-Generierung
      if (pipelineConfig.generateScripts) {
        pipelineResult.steps.push({ name: 'script_generation', status: 'running' });
        console.log('‚úçÔ∏è Starte Script-Generierung...');

        // Kombiniere gescrapte Inhalte und Video-Daten f√ºr die Script-Generierung
        const combinedContent = this.combineContentForScripting(
          pipelineResult.data.scrapedContent,
          pipelineResult.data.videoDiscovery
        );

        const scriptResult = await this.scriptService.generateMultipleScripts(
          combinedContent,
          {
            count: pipelineConfig.maxScripts,
            contentType: pipelineConfig.contentType,
            targetLength: pipelineConfig.targetLength,
            tone: pipelineConfig.tone,
            audience: pipelineConfig.audience
          }
        );

        pipelineResult.data.scripts = scriptResult;
        pipelineResult.steps[pipelineResult.steps.length - 1].status = 'completed';
        pipelineResult.steps[pipelineResult.steps.length - 1].result = scriptResult;
        console.log('‚úÖ Script-Generierung abgeschlossen');
      }

      // Schritt 4: SEO-Optimierung
      if (pipelineConfig.optimizeSEO) {
        pipelineResult.steps.push({ name: 'seo_optimization', status: 'running' });
        console.log('üîç Starte SEO-Optimierung...');

        const seoResult = await this.performSEOOptimization(pipelineResult.data, pipelineConfig);

        pipelineResult.data.seo = seoResult;
        pipelineResult.steps[pipelineResult.steps.length - 1].status = 'completed';
        pipelineResult.steps[pipelineResult.steps.length - 1].result = seoResult;
        console.log('‚úÖ SEO-Optimierung abgeschlossen');
      }

      // Schritt 5: Thumbnail-Erstellung
      if (pipelineConfig.createThumbnails) {
        pipelineResult.steps.push({ name: 'thumbnail_creation', status: 'running' });
        console.log('üé® Starte Thumbnail-Erstellung...');

        // F√ºr Demo-Zwecke simulieren wir die Thumbnail-Erstellung
        const thumbnailResult = {
          success: true,
          thumbnails: Array(pipelineConfig.maxScripts || 5).fill().map((_, i) => ({
            id: `thumb_${i}`,
            url: `https://example.com/thumbnail_${i}.png`,
            template: 'default'
          })),
          metadata: {
            generatedAt: new Date().toISOString(),
            templateUsed: 'default'
          }
        };

        pipelineResult.data.thumbnails = thumbnailResult;
        pipelineResult.steps[pipelineResult.steps.length - 1].status = 'completed';
        pipelineResult.steps[pipelineResult.steps.length - 1].result = thumbnailResult;
        console.log('‚úÖ Thumbnail-Erstellung abgeschlossen');
      }

      // Pipeline abschlie√üen
      pipelineResult.metadata.status = 'completed';
      pipelineResult.metadata.completedAt = new Date().toISOString();
      pipelineResult.metadata.duration = Date.now() - startTime;

      console.log(`üéâ Pipeline ${pipelineId} erfolgreich abgeschlossen in ${pipelineResult.metadata.duration}ms`);
      return pipelineResult;

    } catch (error) {
      console.error(`‚ùå Pipeline ${pipelineId} fehlgeschlagen:`, error);
      pipelineResult.metadata.status = 'failed';
      pipelineResult.metadata.error = error.message;
      pipelineResult.metadata.completedAt = new Date().toISOString();
      return pipelineResult;
    }
  }

  /**
   * NEW: Create end-to-end content generation pipeline
   */
  async createPipeline(pipelineConfig = {}) {
    try {
      console.log('üîÑ Creating end-to-end content generation pipeline...');

      const {
        scrapeContent = true,
        generateScripts = true,
        createThumbnails = true,
        repurposeContent = false,
        monetizationAnalysis = true,
        contentType = 'news',
        targetLength = '5min',
        tone = 'informative',
        audience = 'tech_enthusiasts',
        customInstructions = '',
        maxScripts = 5,
        retryAttempts = 3,
        retryDelay = 1000
      } = pipelineConfig;

      const pipelineId = uuidv4();
      const startTime = Date.now();

      // Pipeline state tracking
      const pipelineState = {
        id: pipelineId,
        status: 'running',
        steps: {
          scrapedContent: 0,
          generatedScripts: 0,
          thumbnails: 0,
          repurposedContent: 0,
          monetizationAnalyses: 0
        },
        errors: [],
        startTime: new Date().toISOString()
      };

      console.log(`üöÄ Starting pipeline ${pipelineId}...`);

      // Step 1: Scrape content if enabled
      let scrapedContent = [];
      if (scrapeContent) {
        console.log('üîç Step 1: Scraping content from social media and news sources...');

        try {
          const scrapeResult = await this.webScrapingService.scrapeAllSources();

          if (scrapeResult.success) {
            scrapedContent = scrapeResult.topItems || [];
            pipelineState.steps.scrapedContent = scrapedContent.length;
            console.log(`‚úÖ Scraped ${scrapedContent.length} items`);
          } else {
            const error = new Error(`Content scraping failed: ${scrapeResult.reason || scrapeResult.error}`);
            pipelineState.errors.push({
              step: 'scraping',
              error: error.message,
              timestamp: new Date().toISOString()
            });
            console.warn('‚ö†Ô∏è Content scraping failed:', scrapeResult.reason || scrapeResult.error);
          }
        } catch (error) {
          pipelineState.errors.push({
            step: 'scraping',
            error: error.message,
            timestamp: new Date().toISOString()
          });
          console.error('‚ùå Content scraping error:', error.message);
        }
      }

      // Step 2: Generate scripts if enabled
      let generatedScripts = [];
      if (generateScripts && scrapedContent.length > 0) {
        console.log('üìù Step 2: Generating scripts from scraped content...');

        // Generate scripts for top items (up to maxScripts)
        const itemsToProcess = scrapedContent.slice(0, maxScripts);

        for (let i = 0; i < itemsToProcess.length; i++) {
          const item = itemsToProcess[i];

          // Retry logic for script generation
          let scriptResult = null;
          let attempt = 0;

          while (attempt <= retryAttempts && !scriptResult) {
            try {
              const scriptJob = {
                topic: item.title,
                contentType: contentType,
                targetLength: targetLength,
                tone: tone,
                audience: audience,
                trendingKeywords: item.tags || [],
                sourceContent: item.content,
                customInstructions: customInstructions
              };

              scriptResult = await this.processJob(scriptJob);
              generatedScripts.push({
                ...scriptResult,
                sourceItem: item
              });

              pipelineState.steps.generatedScripts = generatedScripts.length;
              console.log(`‚úÖ Script generated for: ${item.title.substring(0, 50)}...`);
            } catch (error) {
              attempt++;
              if (attempt <= retryAttempts) {
                console.warn(`‚ö†Ô∏è Script generation failed for: ${item.title}, retrying in ${retryDelay}ms... (attempt ${attempt}/${retryAttempts})`);
                await new Promise(resolve => setTimeout(resolve, retryDelay * Math.pow(2, attempt - 1))); // Exponential backoff
              } else {
                pipelineState.errors.push({
                  step: 'script-generation',
                  item: item.title,
                  error: error.message,
                  timestamp: new Date().toISOString()
                });
                console.error(`‚ùå Failed to generate script for: ${item.title}`, error.message);
              }
            }
          }
        }
      }

      // Step 3: Create thumbnails if enabled
      let thumbnails = [];
      if (createThumbnails && generatedScripts.length > 0) {
        console.log('üñºÔ∏è Step 3: Generating thumbnails...');

        for (let i = 0; i < generatedScripts.length; i++) {
          const script = generatedScripts[i];

          try {
            const thumbnailData = await this.generateThumbnail({
              title: script.sourceItem.title,
              contentType: contentType,
              trendingKeywords: script.sourceItem.tags || [],
              qualityScore: script.qualityScore,
              platform: 'youtube'
            });

            thumbnails.push({
              scriptId: script.jobId,
              thumbnail: thumbnailData
            });

            pipelineState.steps.thumbnails = thumbnails.length;
            console.log(`‚úÖ Thumbnail generated for script: ${script.jobId}`);
          } catch (error) {
            pipelineState.errors.push({
              step: 'thumbnail-generation',
              scriptId: script.jobId,
              error: error.message,
              timestamp: new Date().toISOString()
            });
            console.error(`‚ùå Failed to generate thumbnail for script: ${script.jobId}`, error.message);
          }
        }
      }

      // Step 4: Repurpose content if enabled
      let repurposedContent = [];
      if (repurposeContent && generatedScripts.length > 0) {
        console.log('üîÑ Step 4: Repurposing content...');
        // Implementation would go here
        console.log('‚ÑπÔ∏è Content repurposing step completed (implementation pending)');
      }

      // Step 5: Monetization analysis if enabled
      let monetizationData = [];
      if (monetizationAnalysis && generatedScripts.length > 0) {
        console.log('üí∞ Step 5: Performing monetization analysis...');

        for (let i = 0; i < generatedScripts.length; i++) {
          const script = generatedScripts[i];

          try {
            const monetization = this.estimateMonetizationPotential({
              contentType: contentType,
              targetLength: targetLength,
              qualityScore: script.qualityScore,
              audience: audience,
              trendingKeywords: script.sourceItem.tags || []
            });

            monetizationData.push({
              scriptId: script.jobId,
              monetization: monetization
            });

            pipelineState.steps.monetizationAnalyses = monetizationData.length;
            console.log(`‚úÖ Monetization analysis completed for script: ${script.jobId}`);
          } catch (error) {
            pipelineState.errors.push({
              step: 'monetization-analysis',
              scriptId: script.jobId,
              error: error.message,
              timestamp: new Date().toISOString()
            });
            console.error(`‚ùå Failed monetization analysis for script: ${script.jobId}`, error.message);
          }
        }
      }

      // Calculate pipeline duration
      const duration = Date.now() - startTime;

      // Compile pipeline results
      const pipelineResult = {
        pipelineId,
        config: pipelineConfig,
        state: pipelineState,
        steps: {
          scrapedContent: scrapedContent.length,
          generatedScripts: generatedScripts.length,
          thumbnails: thumbnails.length,
          repurposedContent: repurposedContent.length,
          monetizationAnalyses: monetizationData.length
        },
        data: {
          scrapedContent,
          generatedScripts,
          thumbnails,
          repurposedContent,
          monetizationData
        },
        performance: {
          duration,
          startTime: new Date(startTime).toISOString(),
          endTime: new Date().toISOString()
        },
        errors: pipelineState.errors,
        generatedAt: new Date().toISOString()
      };

      // Save pipeline result
      this.savePipelineResult(pipelineId, pipelineResult);

      // Update pipeline status
      pipelineState.status = 'completed';
      pipelineState.endTime = new Date().toISOString();

      console.log(`üéâ Pipeline ${pipelineId} completed successfully in ${duration}ms`);
      console.log(`üìä Results: ${generatedScripts.length} scripts, ${thumbnails.length} thumbnails, ${monetizationData.length} monetization analyses`);

      if (pipelineState.errors.length > 0) {
        console.warn(`‚ö†Ô∏è Pipeline completed with ${pipelineState.errors.length} errors:`);
        pipelineState.errors.forEach((err, index) => {
          console.warn(`   ${index + 1}. ${err.step}: ${err.error}`);
        });
      }

      return pipelineResult;
    } catch (error) {
      console.error('‚ùå Pipeline execution failed:', error);
      throw error;
    }
  }

  /**
   * Process a complete content generation pipeline
   */
  async processCompletePipeline(jobData) {
    try {
      console.log('üöÄ Starting complete content generation pipeline...');

      const startTime = Date.now();

      // Step 1: Scrape relevant content
      console.log('üîç Step 1: Scraping relevant content...');
      const scrapedContent = await this.scrapingService.scrapeContentForTopic(jobData.topic);

      // Step 2: Analyze scraped content
      console.log('üìä Step 2: Analyzing scraped content...');
      const contentAnalysis = await this.analyzeScrapedContent(scrapedContent);

      // Step 3: Generate script
      console.log('üìù Step 3: Generating script...');
      const scriptData = await this.scriptService.generateScript({
        topic: jobData.topic,
        contentType: jobData.contentType,
        targetLength: jobData.targetLength,
        tone: jobData.tone,
        sourceContent: contentAnalysis.summary,
        trendingKeywords: contentAnalysis.keywords,
        customInstructions: jobData.customInstructions
      });

      // Step 4: Optimize for SEO
      console.log('üîç Step 4: Optimizing for SEO...');
      const seoData = await this.seoService.optimizeContent({
        title: scriptData.title,
        description: scriptData.description,
        tags: scriptData.tags,
        contentType: jobData.contentType,
        targetPlatform: 'youtube'
      });

      // Step 5: Generate thumbnail
      console.log('üé® Step 5: Generating thumbnail...');
      const thumbnailData = await this.generateThumbnail({
        title: scriptData.title,
        contentType: jobData.contentType,
        trendingKeywords: contentAnalysis.keywords,
        qualityScore: scriptData.qualityScore,
        platform: 'youtube'
      });

      // Step 6: Estimate monetization potential
      console.log('üí∞ Step 6: Estimating monetization potential...');
      const monetizationData = this.estimateMonetizationPotential({
        contentType: jobData.contentType,
        targetLength: jobData.targetLength,
        qualityScore: scriptData.qualityScore,
        audience: jobData.audience,
        trendingKeywords: contentAnalysis.keywords
      });

      const totalTime = Date.now() - startTime;

      // Compile final result
      const result = {
        jobId: jobData.jobId || this.generateJobId(),
        pipelineSteps: {
          scraping: {
            status: 'completed',
            data: scrapedContent,
            processingTime: contentAnalysis.processingTime
          },
          analysis: {
            status: 'completed',
            data: contentAnalysis,
            processingTime: contentAnalysis.processingTime
          },
          scriptGeneration: {
            status: 'completed',
            data: scriptData,
            processingTime: scriptData.processingTime
          },
          seoOptimization: {
            status: 'completed',
            data: seoData,
            processingTime: seoData.processingTime
          },
          thumbnailGeneration: {
            status: 'completed',
            data: thumbnailData,
            processingTime: thumbnailData.processingTime
          },
          monetizationEstimation: {
            status: 'completed',
            data: monetizationData,
            processingTime: monetizationData.processingTime
          }
        },
        finalOutput: {
          script: scriptData,
          seo: seoData,
          thumbnail: thumbnailData,
          monetization: monetizationData
        },
        metadata: {
          totalTime: totalTime,
          startTime: new Date(startTime).toISOString(),
          completedAt: new Date().toISOString(),
          qualityScore: this.calculateOverallQualityScore([
            contentAnalysis.qualityScore,
            scriptData.qualityScore,
            seoData.qualityScore,
            thumbnailData.qualityScore
          ])
        }
      };

      // Save pipeline result
      this.savePipelineResult(result.jobId, result);

      console.log(`‚úÖ Complete pipeline finished in ${totalTime}ms with quality score: ${result.metadata.qualityScore}/100`);

      return result;
    } catch (error) {
      console.error('‚ùå Complete pipeline failed:', error);
      throw error;
    }
  }

  /**
   * Process a complete content generation pipeline with SEO-first approach
   */
  async processCompletePipeline(jobData) {
    try {
      console.log('üöÄ Starting complete content generation pipeline with SEO-first approach...');

      const startTime = Date.now();

      // Step 1: SEO Keyword Research (parallel execution)
      console.log('üîç Step 1: SEO Keyword Research...');
      const seoKeywords = await this.performSEOKeywordResearch(jobData.topic);

      // Step 2: Targeted scraping based on SEO keywords
      console.log('üîç Step 2: Targeted scraping based on SEO keywords...');
      const scrapedContent = await this.scrapingService.scrapeContentForTopicWithKeywords(
        jobData.topic,
        seoKeywords.keywords
      );

      // Step 3: Analyze scraped content
      console.log('üìä Step 3: Analyzing scraped content...');
      const contentAnalysis = await this.analyzeScrapedContent(scrapedContent);

      // Step 4: Generate script
      console.log('üìù Step 4: Generating script...');
      const scriptData = await this.scriptService.generateScript({
        topic: jobData.topic,
        contentType: jobData.contentType,
        targetLength: jobData.targetLength,
        tone: jobData.tone,
        sourceContent: contentAnalysis.summary,
        trendingKeywords: contentAnalysis.keywords,
        customInstructions: jobData.customInstructions
      });

      // Step 5: Optimize for SEO
      console.log('üîç Step 5: Optimizing for SEO...');
      const seoData = await this.seoService.optimizeContent({
        title: scriptData.title,
        description: scriptData.description,
        tags: scriptData.tags,
        contentType: jobData.contentType,
        targetPlatform: 'youtube'
      });

      // Step 6: Generate thumbnail
      console.log('üé® Step 6: Generating thumbnail...');
      const thumbnailData = await this.generateThumbnail({
        title: scriptData.title,
        contentType: jobData.contentType,
        trendingKeywords: contentAnalysis.keywords,
        qualityScore: scriptData.qualityScore,
        platform: 'youtube'
      });

      // Step 7: Estimate monetization potential
      console.log('üí∞ Step 7: Estimating monetization potential...');
      const monetizationData = this.estimateMonetizationPotential({
        contentType: jobData.contentType,
        targetLength: jobData.targetLength,
        qualityScore: scriptData.qualityScore,
        audience: jobData.audience,
        trendingKeywords: contentAnalysis.keywords
      });

      const totalTime = Date.now() - startTime;

      // Compile final result
      const result = {
        jobId: jobData.jobId || this.generateJobId(),
        pipelineSteps: {
          seoResearch: {
            status: 'completed',
            data: seoKeywords,
            processingTime: seoKeywords.processingTime || 0
          },
          scraping: {
            status: 'completed',
            data: scrapedContent,
            processingTime: contentAnalysis.processingTime
          },
          analysis: {
            status: 'completed',
            data: contentAnalysis,
            processingTime: contentAnalysis.processingTime
          },
          scriptGeneration: {
            status: 'completed',
            data: scriptData,
            processingTime: scriptData.processingTime
          },
          seoOptimization: {
            status: 'completed',
            data: seoData,
            processingTime: seoData.processingTime
          },
          thumbnailGeneration: {
            status: 'completed',
            data: thumbnailData,
            processingTime: thumbnailData.processingTime
          },
          monetizationEstimation: {
            status: 'completed',
            data: monetizationData,
            processingTime: monetizationData.processingTime
          }
        },
        finalOutput: {
          script: scriptData,
          seo: seoData,
          thumbnail: thumbnailData,
          monetization: monetizationData
        },
        metadata: {
          totalTime: totalTime,
          startTime: new Date(startTime).toISOString(),
          completedAt: new Date().toISOString(),
          qualityScore: this.calculateOverallQualityScore([
            contentAnalysis.qualityScore,
            scriptData.qualityScore,
            seoData.qualityScore,
            thumbnailData.qualityScore
          ])
        }
      };

      // Save pipeline result
      this.savePipelineResult(result.jobId, result);

      console.log(`‚úÖ Complete pipeline finished in ${totalTime}ms with quality score: ${result.metadata.qualityScore}/100`);

      return result;
    } catch (error) {
      console.error('‚ùå Complete pipeline failed:', error);
      throw error;
    }
  }

  /**
   * Perform SEO keyword research for a topic
   */
  async performSEOKeywordResearch(topic) {
    try {
      console.log(`üîç Performing SEO keyword research for topic: "${topic}"`);

      const startTime = Date.now();

      // Use the enhanced SEO service for keyword research
      const keywordData = await this.enhancedSeoService.performSEOKeywordResearch(topic);

      if (!keywordData.success) {
        throw new Error(keywordData.error || 'SEO keyword research failed');
      }

      const processingTime = Date.now() - startTime;

      console.log(`‚úÖ SEO keyword research completed: ${keywordData.allKeywords.length} keywords found`);

      return {
        primaryKeywords: keywordData.primaryKeywords,
        relatedKeywords: keywordData.relatedKeywords,
        keywords: keywordData.allKeywords,
        processingTime: processingTime,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      console.error('‚ùå SEO keyword research failed:', error);
      return {
        primaryKeywords: [topic],
        relatedKeywords: [],
        keywords: [topic],
        processingTime: 0,
        timestamp: new Date().toISOString(),
        error: error.message
      };
    }
  }

  /**
   * Perform web scraping as part of pipeline
   */
  async performWebScraping(pipelineId, topic, options = {}) {
    try {
      console.log(`üîç Performing web scraping for pipeline ${pipelineId}`);

      // Scrape content for the topic
      const scrapeResult = await this.scrapingService.scrapeContentWithKeywords([topic]);

      // Save to pipeline results
      const pipelineResult = {
        contentItems: scrapeResult.contentItems,
        totalCount: scrapeResult.totalCount,
        relevantCount: scrapeResult.relevantCount,
        sources: scrapeResult.sources
      };

      await this.savePipelineResult(pipelineId, 'scraped_content', pipelineResult);

      console.log(`‚úÖ Web scraping completed for pipeline ${pipelineId}: ${scrapeResult.contentItems.length} items`);
      return pipelineResult;
    } catch (error) {
      console.error('‚ùå Web scraping failed:', error);
      throw error;
    }
  }

  /**
   * Process multi-input as part of pipeline
   */
  async processMultiInput(pipelineId, contentId, options = {}) {
    try {
      console.log(`üîÑ Processing multi-input for pipeline ${pipelineId}`);

      // For now, we'll just return a placeholder result
      // In a real implementation, this would process multiple input sources
      const result = {
        processedItems: 0,
        consolidatedContent: '',
        metadata: {
          processedAt: new Date().toISOString(),
          pipelineId: pipelineId
        }
      };

      await this.savePipelineResult(pipelineId, 'multi_input', result);

      console.log(`‚úÖ Multi-input processing completed for pipeline ${pipelineId}`);
      return result;
    } catch (error) {
      console.error('‚ùå Multi-input processing failed:', error);
      throw error;
    }
  }

  /**
   * Repurpose content as part of pipeline
   */
  async repurposeContent(pipelineId, contentId, options = {}) {
    try {
      console.log(`‚ôªÔ∏è Repurposing content for pipeline ${pipelineId}`);

      // For now, we'll just return a placeholder result
      // In a real implementation, this would repurpose content for different platforms
      const result = {
        repurposedItems: 0,
        platforms: [],
        metadata: {
          repurposedAt: new Date().toISOString(),
          pipelineId: pipelineId
        }
      };

      await this.savePipelineResult(pipelineId, 'repurposed_content', result);

      console.log(`‚úÖ Content repurposing completed for pipeline ${pipelineId}`);
      return result;
    } catch (error) {
      console.error('‚ùå Content repurposing failed:', error);
      throw error;
    }
  }

  /**
   * Analyze monetization as part of pipeline
   */
  async analyzeMonetization(pipelineId, contentId, options = {}) {
    try {
      console.log(`üí∞ Analyzing monetization for pipeline ${pipelineId}`);

      // For now, we'll just return a placeholder result
      // In a real implementation, this would analyze monetization potential
      const result = {
        estimatedViews: 0,
        estimatedRevenue: 0,
        revenueBreakdown: {},
        metadata: {
          analyzedAt: new Date().toISOString(),
          pipelineId: pipelineId
        }
      };

      await this.savePipelineResult(pipelineId, 'monetization', result);

      console.log(`‚úÖ Monetization analysis completed for pipeline ${pipelineId}`);
      return result;
    } catch (error) {
      console.error('‚ùå Monetization analysis failed:', error);
      throw error;
    }
  }

  /**
   * Generate thumbnails as part of pipeline
   */
  async generateThumbnails(pipelineId, thumbnailData) {
    try {
      console.log(`üé® Generating thumbnails for pipeline ${pipelineId}`);

      // Generate thumbnail
      const thumbnailResult = await this.thumbnailService.generateThumbnail(thumbnailData);

      // Save to pipeline results
      await this.savePipelineResult(pipelineId, 'thumbnail', thumbnailResult);

      console.log(`‚úÖ Thumbnail generation completed for pipeline ${pipelineId}`);
      return thumbnailResult;
    } catch (error) {
      console.error('‚ùå Thumbnail generation failed:', error);
      throw error;
    }
  }

  /**
   * Create a new content pipeline
   */
  async createPipeline(channelId, topic, options = {}) {
    try {
      console.log(`\nüöÄ Creating new pipeline for channel ${channelId} on topic: "${topic}"`);

      // Generate unique pipeline ID
      const pipelineId = uuidv4();

      // Initialize pipeline state
      const pipelineState = {
        pipelineId,
        channelId,
        topic,
        status: 'initializing',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        steps: {},
        options
      };

      // Save initial pipeline state
      await this.savePipelineState(pipelineState);

      // Execute pipeline steps in order
      const steps = [
        { id: 'webScraping', name: 'Web Scraping', handler: () => this.performWebScraping(pipelineId, topic, options) },
        { id: 'multiInputProcessing', name: 'Multi-Input Processing', handler: () => this.processMultiInput(pipelineId, pipelineId, options) }, // Note: using pipelineId as contentId for now
        { id: 'scriptGeneration', name: 'Script Generation', handler: () => this.generateScript(pipelineId, topic, options) },
        { id: 'contentRepurposing', name: 'Content Repurposing', handler: () => this.repurposeContent(pipelineId, pipelineId, options) }, // Note: using pipelineId as contentId for now
        { id: 'monetizationAnalysis', name: 'Monetization Analysis', handler: () => this.analyzeMonetization(pipelineId, pipelineId, options) }, // Note: using pipelineId as contentId for now
        { id: 'thumbnailGeneration', name: 'Thumbnail Generation', handler: () => this.generateThumbnails(pipelineId, { title: topic, ...options }) }
      ];

      // Execute each step
      for (const step of steps) {
        try {
          console.log(`\n‚öôÔ∏è  Executing pipeline step: ${step.name}`);
          pipelineState.steps[step.id] = { status: 'in_progress', startedAt: new Date().toISOString() };
          await this.savePipelineState(pipelineState);

          const result = await step.handler();

          pipelineState.steps[step.id] = {
            status: 'completed',
            completedAt: new Date().toISOString(),
            result
          };
          pipelineState.updatedAt = new Date().toISOString();
          await this.savePipelineState(pipelineState);

          console.log(`‚úÖ Pipeline step completed: ${step.name}`);
        } catch (error) {
          console.error(`‚ùå Pipeline step failed: ${step.name}`, error);
          pipelineState.steps[step.id] = {
            status: 'failed',
            failedAt: new Date().toISOString(),
            error: error.message
          };
          pipelineState.status = 'failed';
          pipelineState.updatedAt = new Date().toISOString();
          await this.savePipelineState(pipelineState);
          throw error;
        }
      }

      // Update pipeline status to completed
      pipelineState.status = 'completed';
      pipelineState.updatedAt = new Date().toISOString();
      await this.savePipelineState(pipelineState);

      console.log(`‚úÖ Pipeline completed for channel ${channelId} on topic: "${topic}"`);
      return pipelineState;
    } catch (error) {
      console.error('‚ùå Pipeline creation failed:', error);
      throw error;
    }
  }

  /**
   * Generate a unique job ID
   */
  generateJobId() {
    return uuidv4();
  }

  /**
   * Calculate overall quality score from individual scores
   */
  calculateOverallQualityScore(scores) {
    const totalScore = scores.reduce((sum, score) => sum + score, 0);
    return Math.round((totalScore / scores.length) * 100);
  }

  /**
   * Save pipeline state
   */
  savePipelineState(pipelineState) {
    // Implement your logic to save pipeline state to a database or storage
    console.log(`Saving pipeline state for pipeline ${pipelineState.pipelineId}`);
  }

  /**
   * Save pipeline result
   */
    console.log(Saving \ result for pipeline \);
    // Implement your logic to save pipeline results to a database or storage
    console.log(Saving  result for pipeline );
  }

      // Finalize pipeline
      pipelineState.status = 'completed';
      pipelineState.completedAt = new Date().toISOString();
      pipelineState.updatedAt = new Date().toISOString();
      await this.savePipelineState(pipelineState);

      console.log(`\nüéâ Pipeline ${pipelineId} completed successfully!`);
      return pipelineState;
    } catch (error) {
      console.error('‚ùå Pipeline creation failed:', error);
      throw error;
    }
  }

  /**
   * Generate script as part of pipeline
   */
  async generateScript(pipelineId, topic, options = {}) {
    try {
      console.log(`üìù Generating script for pipeline ${pipelineId}`);

      // Prepare script data
      const scriptData = {
        topic,
        contentType: options.contentType || 'explanation',
        targetLength: options.targetLength || '5min',
        tone: options.tone || 'informativ',
        audience: options.audience || 'all',
        trendingKeywords: options.trendingKeywords || [],
        customInstructions: options.customInstructions || '',
        useChainOfThought: options.useChainOfThought !== false, // Default to true
        enableSelfReflection: options.enableSelfReflection !== false // Default to true
      };

      // Generate script
      const scriptResult = await this.scriptService.generateScript(scriptData);

      // Perform final quality check before approving for video production
      console.log(`üîç Performing final quality check for script ${scriptResult.scriptId}`);
      const qualityCheck = await this.scriptService.finalQualityCheck(
        scriptResult.scriptId,
        scriptResult.content,
        scriptResult.metadata
      );

      // Check approval status
      if (qualityCheck.approvalStatus === 'rejected') {
        throw new Error(`Script rejected due to quality issues: ${qualityCheck.approvalReason}`);
      }

      // Add quality check results to script metadata
      scriptResult.metadata.qualityCheck = qualityCheck;

      // Save updated script with quality check results
      this.scriptService.saveScript(scriptResult.scriptId, scriptResult.content, scriptResult.metadata);

      console.log(`‚úÖ Script generated and approved for production: ${scriptResult.scriptId}`);

      // Save to pipeline results
      const pipelineResult = {
        scriptId: scriptResult.scriptId,
        content: scriptResult.content,
        metadata: scriptResult.metadata
      };

      await this.savePipelineResult(pipelineId, 'script', pipelineResult);

      return pipelineResult;
    } catch (error) {
      console.error('‚ùå Script generation failed:', error);
      throw error;
    }
  }

  /**
   * Scrape content specifically for a topic
   */
  async scrapeContentForTopic(topic) {
    try {
      // Use multi-source scraping
      const redditContent = await this.scrapingService.scrapeReddit();
      const newsContent = await this.scrapingService.scrapeTechNews();
      const webContent = await this.scrapingService.scrapeWebForTopic(topic);

      // Filter and rank content by relevance to topic
      const allContent = [...redditContent, ...newsContent, ...webContent];
      const relevantContent = allContent
        .filter(item => this.isContentRelevantToTopic(item, topic))
        .sort((a, b) => (b.qualityScore || 0) - (a.qualityScore || 0))
        .slice(0, 20); // Top 20 most relevant pieces

      return {
        contentItems: relevantContent,
        totalCount: allContent.length,
        relevantCount: relevantContent.length,
        sources: {
          reddit: redditContent.length,
          news: newsContent.length,
          web: webContent.length
        }
      };
    } catch (error) {
      console.error('‚ùå Topic-specific scraping failed:', error);
      return {
        contentItems: [],
        totalCount: 0,
        relevantCount: 0,
        sources: {}
      };
    }
  }

  /**
   * Analyze scraped content for pipeline use
   */
  async analyzeScrapedContent(scrapedData) {
    try {
      const startTime = Date.now();

      if (!scrapedData.contentItems || scrapedData.contentItems.length === 0) {
        throw new Error('No content to analyze');
      }

      // Extract key information from all content items
      let combinedText = '';
      const allKeywords = [];
      const categories = {};
      let totalQualityScore = 0;

      scrapedData.contentItems.forEach(item => {
        combinedText += (item.title || '') + ' ' + (item.content || '') + ' ';
        if (item.keywords) allKeywords.push(...item.keywords);
        if (item.category) {
          categories[item.category] = (categories[item.category] || 0) + 1;
        }
        if (item.qualityScore) totalQualityScore += item.qualityScore;
      });

      // Determine primary category
      const primaryCategory = Object.entries(categories)
        .sort((a, b) => b[1] - a[1])[0]?.[0] || 'general';

      // Extract top keywords
      const keywordFreq = {};
      allKeywords.forEach(keyword => {
        keywordFreq[keyword] = (keywordFreq[keyword] || 0) + 1;
      });

      const topKeywords = Object.entries(keywordFreq)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10)
        .map(([keyword]) => keyword);

      // Generate summary using AI service
      const summary = await this.generateContentSummary(combinedText, primaryCategory);

      const processingTime = Date.now() - startTime;

      return {
        summary: summary,
        keywords: topKeywords,
        category: primaryCategory,
        qualityScore: Math.round(totalQualityScore / scrapedData.contentItems.length),
        contentCount: scrapedData.contentItems.length,
        processingTime: processingTime,
        sources: scrapedData.sources
      };
    } catch (error) {
      console.error('‚ùå Content analysis failed:', error);
      return {
        summary: 'Content analysis failed',
        keywords: [],
        category: 'unknown',
        qualityScore: 50,
        contentCount: 0,
        processingTime: 0,
        sources: {}
      };
    }
  }

  /**
   * Generate content summary using AI
   */
  async generateContentSummary(text, category) {
    try {
      // In a real implementation, this would use an LLM service
      // For now, we'll create a mock summary
      const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
      const firstSentences = sentences.slice(0, 3).join(' ');

      return `This is a summary of ${category} content. Key points include: ${firstSentences.substring(0, 200)}...`;
    } catch (error) {
      console.error('‚ùå Summary generation failed:', error);
      return 'Content summary unavailable';
    }
  }

  /**
   * Check if content is relevant to a topic
   */
  isContentRelevantToTopic(content, topic) {
    const topicWords = topic.toLowerCase().split(/\s+/);
    const contentText = ((content.title || '') + ' ' + (content.content || '')).toLowerCase();

    // Check if any topic words appear in content
    return topicWords.some(word => contentText.includes(word));
  }

  /**
   * Calculate overall quality score
   */
  calculateOverallQualityScore(scores) {
    if (scores.length === 0) return 50;

    const sum = scores.reduce((acc, score) => acc + (score || 50), 0);
    return Math.round(sum / scores.length);
  }

  /**
   * Generate unique job ID
   */
  generateJobId() {
    return 'job_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  }

  /**
   * Save pipeline state to file
   */
  async savePipelineState(pipelineState) {
    try {
      const pipelineDir = path.join(this.jobsDir, 'pipelines');
      if (!fs.existsSync(pipelineDir)) {
        fs.mkdirSync(pipelineDir, { recursive: true });
      }

      const filepath = path.join(pipelineDir, `${pipelineState.pipelineId}.json`);
      fs.writeFileSync(filepath, JSON.stringify(pipelineState, null, 2));
    } catch (error) {
      console.error('‚ùå Failed to save pipeline state:', error);
      // Don't throw error as this shouldn't break the pipeline
    }
  }

  /**
   * Load pipeline state from file
   */
  async loadPipelineState(pipelineId) {
    try {
      const filepath = path.join(this.jobsDir, 'pipelines', `${pipelineId}.json`);
      if (fs.existsSync(filepath)) {
        const data = fs.readFileSync(filepath, 'utf8');
        return JSON.parse(data);
      }
      return null;
    } catch (error) {
      console.error('‚ùå Failed to load pipeline state:', error);
      return null;
    }
  }

  /**
   * Save pipeline result
   */
  async savePipelineResult(pipelineId, resultType, resultData) {
    // Implement your logic to save pipeline results to a database or storage
    console.log(`Saving ${resultType} result for pipeline ${pipelineId}`);
  }
    } catch (error) {
      console.error('‚ùå Failed to save pipeline result:', error);
      // Don't throw error as this shouldn't break the pipeline
    }
  }

  /**
   * Create a new content pipeline
   */
  async createPipeline(config = {}) {
    try {
      const pipelineId = uuidv4();
      const { topic, channel, options = {} } = config;

      console.log(`\nüöÄ Creating new pipeline ${pipelineId} for channel ${channel} on topic: "${topic}"`);

      // Initialize pipeline state
      const pipelineState = {
        pipelineId,
        topic,
        channel,
        status: 'initialized',
        config: options,
        steps: {},
        data: {},
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      // Save initial pipeline state
      await this.savePipelineState(pipelineState);

      // Execute pipeline steps in order
      const steps = [
        { id: 'webScraping', name: 'Web Scraping', handler: () => this.performWebScraping(pipelineId, topic, options) },
        { id: 'multiInputProcessing', name: 'Multi-Input Processing', handler: () => this.processMultiInput(pipelineId, pipelineId, options) }, // Note: using pipelineId as contentId for now
        { id: 'scriptGeneration', name: 'Script Generation', handler: () => this.generateScript(pipelineId, topic, options) },
        { id: 'contentRepurposing', name: 'Content Repurposing', handler: () => this.repurposeContent(pipelineId, pipelineId, options) }, // Note: using pipelineId as contentId for now
        { id: 'monetizationAnalysis', name: 'Monetization Analysis', handler: () => this.analyzeMonetization(pipelineId, pipelineId, options) }, // Note: using pipelineId as contentId for now
        { id: 'thumbnailGeneration', name: 'Thumbnail Generation', handler: () => this.generateThumbnails(pipelineId, { title: topic, ...options }) }
      ];

      // Execute each step
      for (const step of steps) {
        try {
          console.log(`\n‚öôÔ∏è  Executing pipeline step: ${step.name}`);
          pipelineState.steps[step.id] = { status: 'in_progress', startedAt: new Date().toISOString() };
          await this.savePipelineState(pipelineState);

          const result = await step.handler();

          pipelineState.steps[step.id] = {
            status: 'completed',
            completedAt: new Date().toISOString(),
            result
          };
          pipelineState.updatedAt = new Date().toISOString();
          await this.savePipelineState(pipelineState);

          console.log(`‚úÖ Pipeline step completed: ${step.name}`);
        } catch (error) {
          console.error(`‚ùå Pipeline step failed: ${step.name}`, error);
          pipelineState.steps[step.id] = {
            status: 'failed',
            failedAt: new Date().toISOString(),
            error: error.message
          };
          pipelineState.status = 'failed';
          pipelineState.updatedAt = new Date().toISOString();
          await this.savePipelineState(pipelineState);
          throw error;
        }
      }

      // Finalize pipeline
      pipelineState.status = 'completed';
      pipelineState.completedAt = new Date().toISOString();
      pipelineState.updatedAt = new Date().toISOString();
      await this.savePipelineState(pipelineState);

      console.log(`\nüéâ Pipeline ${pipelineId} completed successfully!`);
      return pipelineState;
    } catch (error) {
      console.error('‚ùå Pipeline creation failed:', error);
      throw error;
    }
  }

  /**
   * Execute a scraping step
   */
  async executeScrape(pipelineState, stepConfig) {
    const scrapedContent = await this.scrapeContent(stepConfig);

    await this.savePipelineResult(pipelineState.pipelineId, 'scrapedContent', scrapedContent);
    return scrapedContent;
  }

  /**
   * Execute a video discovery step
   */
  async executeDiscoverVideos(pipelineState, stepConfig) {
    const videoDiscovery = await this.discoverVideos(stepConfig);

    await this.savePipelineResult(pipelineState.pipelineId, 'videoDiscovery', videoDiscovery);
    return videoDiscovery;
  }

  /**
   * Execute a script generation step
   */
  async executeGenerateScript(pipelineState, stepConfig) {
    const scrapedContent = await this.loadPipelineResult(pipelineState.pipelineId, 'scrapedContent');
    const videoDiscovery = await this.loadPipelineResult(pipelineState.pipelineId, 'videoDiscovery');

    const combinedContent = this.combineContentForScripting(scrapedContent, videoDiscovery);
    const script = await this.generateScript(combinedContent, stepConfig);

    await this.savePipelineResult(pipelineState.pipelineId, 'script', script);
    return script;
  }

  /**
   * Execute an SEO optimization step
   */
  async executeOptimizeSEO(pipelineState, stepConfig) {
    const seoResults = await this.performSEOOptimization(pipelineState);

    await this.savePipelineResult(pipelineState.pipelineId, 'seoResults', seoResults);
    return seoResults;
  }

  /**
   * Kombiniert gescrapte Inhalte f√ºr die Script-Generierung
   * @private
   */
  combineContentForScripting(scrapedContent, videoDiscovery) {
    const combined = {
      articles: [],
      socialMedia: [],
      videos: []
    };

    // Artikel aus gescrapten News-Sites
    if (scrapedContent && scrapedContent.results) {
      scrapedContent.results.forEach(result => {
        if (result.type === 'article') {
          combined.articles.push({
            title: result.title,
            content: result.content,
            source: result.source,
            url: result.url
          });
        } else {
          combined.socialMedia.push({
            content: result.content,
            platform: result.source,
            url: result.url,
            engagement: result.engagement
          });
        }
      });
    }

    // Videos aus der Entdeckung
    if (videoDiscovery && videoDiscovery.videos) {
      combined.videos = videoDiscovery.videos.map(video => ({
        title: video.title,
        description: video.description,
        channel: video.channelTitle,
        views: video.viewCount,
        engagement: video.engagementRate
      }));
    }

    return combined;
  }

  /**
   * F√ºhrt SEO-Optimierung f√ºr Kanal und Videos durch
   * @private
   */
  async performSEOOptimization(pipelineData, config) {
    console.log('üîç F√ºhre SEO-Optimierung durch...');

    const seoResults = {
      channel: null,
      videos: [],
      shorts: []
    };

    try {
      // SEO-Optimierung f√ºr Kanal
      const channelData = {
        channelName: config.channelName || 'Mein YouTube Kanal',
        description: 'Kanal f√ºr informative und unterhaltsame Inhalte',
        topics: ['Technologie', 'KI', 'Politik'],
        targetAudience: config.audience || 'Allgemeines Publikum',
        contentType: config.contentType || 'Tutorial',
        uploadSchedule: 'W√∂chentlich'
      };

      seoResults.channel = await this.seoService.generateChannelDescription(channelData, {
        language: config.language || 'de'
      });

      // SEO-Optimierung f√ºr Long-Form-Videos
      if (pipelineData.scripts && pipelineData.scripts.scripts) {
        for (const script of pipelineData.scripts.scripts) {
          const videoData = {
            title: script.title,
            summary: script.summary,
            chapters: script.chapters,
            keyPoints: script.keyPoints,
            relatedTopics: script.keywords,
            category: config.contentType,
            channelName: channelData.channelName,
            contentType: 'long-form'
          };

          const videoSEO = await this.seoService.generateLongFormVideoDescription(videoData, {
            language: config.language || 'de'
          });

          seoResults.videos.push({
            scriptId: script.id,
            seo: videoSEO
          });
        }
      }

      // SEO-Optimierung f√ºr Shorts (simuliert)
      for (let i = 0; i < 3; i++) {
        const shortData = {
          title: `Kurzvideo ${i + 1}`,
          caption: 'Kurze, knackige Inhalte',
          hashtags: ['#Shorts', '#YouTube', '#Trending'],
          channelName: channelData.channelName,
          contentType: 'short'
        };

        const shortSEO = await this.seoService.generateShortVideoDescription(shortData, {
          language: config.language || 'de'
        });

        seoResults.shorts.push({
          id: `short_${i}`,
          seo: shortSEO
        });
      }

      console.log('‚úÖ SEO-Optimierung abgeschlossen');
      return seoResults;

    } catch (error) {
      console.error('‚ùå Fehler bei der SEO-Optimierung:', error);
      return {
        success: false,
        error: error.message,
        channel: null,
        videos: [],
        shorts: []
      };
    }
  }
}

module.exports = PipelineOrchestrator;